/**
 * Campaign.Core.Identity
 * Swagger document
 *
 * OpenAPI spec version: v1
 * Contact: wangzhen@jixiuapp.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH }                                         from '../variables';
import { Configuration }                                     from '../configuration';

/* tslint:disable:no-unused-variable member-ordering */


@Injectable()
export class ClientApi {
    protected basePath = 'https://openapis.ixingban.com/ids';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }
	
	/**
     * 
     * Extends object by coping non-existing properties.
     * @param objA object to be extended
     * @param objB source object
     */
    private extendObj<T, U>(first: T, second: U): T & U {
        let result = <T & U>{};
        for (let id in first) {
            (<any>result)[id] = (<any>first)[id];
        }
        for (let id in second) {
            if (!result.hasOwnProperty(id)) {
                (<any>result)[id] = (<any>second)[id];
            }
        }
        return result;
    }

    /**
     * 
     * 
     * @param id 
     */
    public clientDelete(id: number, extraHttpRequestParams?: any): Observable<models.SingleResultInt32> {
        return this.clientDeleteWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param id 
     */
    public clientDetail(id: number, extraHttpRequestParams?: any): Observable<models.SingleResultClient> {
        return this.clientDetailWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param skip 
     * @param take 
     */
    public clientGet(skip?: number, take?: number, extraHttpRequestParams?: any): Observable<models.PagingResultClient> {
        return this.clientGetWithHttpInfo(skip, take, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param id 
     * @param enabled 
     * @param clientId 
     * @param normalizedClientId 
     * @param protocolType 
     * @param clientSecrets 
     * @param requireClientSecret 
     * @param clientName 
     * @param description 
     * @param clientUri 
     * @param logoUri 
     * @param requireConsent 
     * @param allowRememberConsent 
     * @param alwaysIncludeUserClaimsInIdToken 
     * @param allowedGrantTypes 
     * @param requirePkce 
     * @param allowPlainTextPkce 
     * @param allowAccessTokensViaBrowser 
     * @param redirectUris 
     * @param postLogoutRedirectUris 
     * @param frontChannelLogoutUri 
     * @param frontChannelLogoutSessionRequired 
     * @param backChannelLogoutUri 
     * @param backChannelLogoutSessionRequired 
     * @param allowOfflineAccess 
     * @param allowedScopes 
     * @param identityTokenLifetime 
     * @param accessTokenLifetime 
     * @param authorizationCodeLifetime 
     * @param consentLifetime 
     * @param absoluteRefreshTokenLifetime 
     * @param slidingRefreshTokenLifetime 
     * @param refreshTokenUsage 
     * @param updateAccessTokenClaimsOnRefresh 
     * @param refreshTokenExpiration 
     * @param accessTokenType 
     * @param enableLocalLogin 
     * @param identityProviderRestrictions 
     * @param includeJwtId 
     * @param claims 
     * @param alwaysSendClientClaims 
     * @param prefixClientClaims 
     * @param allowedCorsOrigins 
     * @param properties 
     */
    public clientPost(id?: number, enabled?: boolean, clientId?: string, normalizedClientId?: string, protocolType?: string, clientSecrets?: Array<string>, requireClientSecret?: boolean, clientName?: string, description?: string, clientUri?: string, logoUri?: string, requireConsent?: boolean, allowRememberConsent?: boolean, alwaysIncludeUserClaimsInIdToken?: boolean, allowedGrantTypes?: Array<string>, requirePkce?: boolean, allowPlainTextPkce?: boolean, allowAccessTokensViaBrowser?: boolean, redirectUris?: Array<string>, postLogoutRedirectUris?: Array<string>, frontChannelLogoutUri?: string, frontChannelLogoutSessionRequired?: boolean, backChannelLogoutUri?: string, backChannelLogoutSessionRequired?: boolean, allowOfflineAccess?: boolean, allowedScopes?: Array<string>, identityTokenLifetime?: number, accessTokenLifetime?: number, authorizationCodeLifetime?: number, consentLifetime?: number, absoluteRefreshTokenLifetime?: number, slidingRefreshTokenLifetime?: number, refreshTokenUsage?: number, updateAccessTokenClaimsOnRefresh?: boolean, refreshTokenExpiration?: number, accessTokenType?: number, enableLocalLogin?: boolean, identityProviderRestrictions?: Array<string>, includeJwtId?: boolean, claims?: Array<string>, alwaysSendClientClaims?: boolean, prefixClientClaims?: boolean, allowedCorsOrigins?: Array<string>, properties?: Array<string>, extraHttpRequestParams?: any): Observable<models.SingleResultInt32> {
        return this.clientPostWithHttpInfo(id, enabled, clientId, normalizedClientId, protocolType, clientSecrets, requireClientSecret, clientName, description, clientUri, logoUri, requireConsent, allowRememberConsent, alwaysIncludeUserClaimsInIdToken, allowedGrantTypes, requirePkce, allowPlainTextPkce, allowAccessTokensViaBrowser, redirectUris, postLogoutRedirectUris, frontChannelLogoutUri, frontChannelLogoutSessionRequired, backChannelLogoutUri, backChannelLogoutSessionRequired, allowOfflineAccess, allowedScopes, identityTokenLifetime, accessTokenLifetime, authorizationCodeLifetime, consentLifetime, absoluteRefreshTokenLifetime, slidingRefreshTokenLifetime, refreshTokenUsage, updateAccessTokenClaimsOnRefresh, refreshTokenExpiration, accessTokenType, enableLocalLogin, identityProviderRestrictions, includeJwtId, claims, alwaysSendClientClaims, prefixClientClaims, allowedCorsOrigins, properties, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param id 
     * @param enabled 
     * @param clientId 
     * @param normalizedClientId 
     * @param protocolType 
     * @param clientSecrets 
     * @param requireClientSecret 
     * @param clientName 
     * @param description 
     * @param clientUri 
     * @param logoUri 
     * @param requireConsent 
     * @param allowRememberConsent 
     * @param alwaysIncludeUserClaimsInIdToken 
     * @param allowedGrantTypes 
     * @param requirePkce 
     * @param allowPlainTextPkce 
     * @param allowAccessTokensViaBrowser 
     * @param redirectUris 
     * @param postLogoutRedirectUris 
     * @param frontChannelLogoutUri 
     * @param frontChannelLogoutSessionRequired 
     * @param backChannelLogoutUri 
     * @param backChannelLogoutSessionRequired 
     * @param allowOfflineAccess 
     * @param allowedScopes 
     * @param identityTokenLifetime 
     * @param accessTokenLifetime 
     * @param authorizationCodeLifetime 
     * @param consentLifetime 
     * @param absoluteRefreshTokenLifetime 
     * @param slidingRefreshTokenLifetime 
     * @param refreshTokenUsage 
     * @param updateAccessTokenClaimsOnRefresh 
     * @param refreshTokenExpiration 
     * @param accessTokenType 
     * @param enableLocalLogin 
     * @param identityProviderRestrictions 
     * @param includeJwtId 
     * @param claims 
     * @param alwaysSendClientClaims 
     * @param prefixClientClaims 
     * @param allowedCorsOrigins 
     * @param properties 
     */
    public clientPut(id?: number, enabled?: boolean, clientId?: string, normalizedClientId?: string, protocolType?: string, clientSecrets?: Array<string>, requireClientSecret?: boolean, clientName?: string, description?: string, clientUri?: string, logoUri?: string, requireConsent?: boolean, allowRememberConsent?: boolean, alwaysIncludeUserClaimsInIdToken?: boolean, allowedGrantTypes?: Array<string>, requirePkce?: boolean, allowPlainTextPkce?: boolean, allowAccessTokensViaBrowser?: boolean, redirectUris?: Array<string>, postLogoutRedirectUris?: Array<string>, frontChannelLogoutUri?: string, frontChannelLogoutSessionRequired?: boolean, backChannelLogoutUri?: string, backChannelLogoutSessionRequired?: boolean, allowOfflineAccess?: boolean, allowedScopes?: Array<string>, identityTokenLifetime?: number, accessTokenLifetime?: number, authorizationCodeLifetime?: number, consentLifetime?: number, absoluteRefreshTokenLifetime?: number, slidingRefreshTokenLifetime?: number, refreshTokenUsage?: number, updateAccessTokenClaimsOnRefresh?: boolean, refreshTokenExpiration?: number, accessTokenType?: number, enableLocalLogin?: boolean, identityProviderRestrictions?: Array<string>, includeJwtId?: boolean, claims?: Array<string>, alwaysSendClientClaims?: boolean, prefixClientClaims?: boolean, allowedCorsOrigins?: Array<string>, properties?: Array<string>, extraHttpRequestParams?: any): Observable<models.SingleResultInt32> {
        return this.clientPutWithHttpInfo(id, enabled, clientId, normalizedClientId, protocolType, clientSecrets, requireClientSecret, clientName, description, clientUri, logoUri, requireConsent, allowRememberConsent, alwaysIncludeUserClaimsInIdToken, allowedGrantTypes, requirePkce, allowPlainTextPkce, allowAccessTokensViaBrowser, redirectUris, postLogoutRedirectUris, frontChannelLogoutUri, frontChannelLogoutSessionRequired, backChannelLogoutUri, backChannelLogoutSessionRequired, allowOfflineAccess, allowedScopes, identityTokenLifetime, accessTokenLifetime, authorizationCodeLifetime, consentLifetime, absoluteRefreshTokenLifetime, slidingRefreshTokenLifetime, refreshTokenUsage, updateAccessTokenClaimsOnRefresh, refreshTokenExpiration, accessTokenType, enableLocalLogin, identityProviderRestrictions, includeJwtId, claims, alwaysSendClientClaims, prefixClientClaims, allowedCorsOrigins, properties, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }


    /**
     * 
     * 
     * @param id 
     */
    public clientDeleteWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/Client/${id}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling clientDelete.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];
        
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     */
    public clientDetailWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/Client/${id}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling clientDetail.');
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];
        
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param skip 
     * @param take 
     */
    public clientGetWithHttpInfo(skip?: number, take?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/Client`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (skip !== undefined) {
            queryParameters.set('skip', <any>skip);
        }
        if (take !== undefined) {
            queryParameters.set('take', <any>take);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];
        
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param enabled 
     * @param clientId 
     * @param normalizedClientId 
     * @param protocolType 
     * @param clientSecrets 
     * @param requireClientSecret 
     * @param clientName 
     * @param description 
     * @param clientUri 
     * @param logoUri 
     * @param requireConsent 
     * @param allowRememberConsent 
     * @param alwaysIncludeUserClaimsInIdToken 
     * @param allowedGrantTypes 
     * @param requirePkce 
     * @param allowPlainTextPkce 
     * @param allowAccessTokensViaBrowser 
     * @param redirectUris 
     * @param postLogoutRedirectUris 
     * @param frontChannelLogoutUri 
     * @param frontChannelLogoutSessionRequired 
     * @param backChannelLogoutUri 
     * @param backChannelLogoutSessionRequired 
     * @param allowOfflineAccess 
     * @param allowedScopes 
     * @param identityTokenLifetime 
     * @param accessTokenLifetime 
     * @param authorizationCodeLifetime 
     * @param consentLifetime 
     * @param absoluteRefreshTokenLifetime 
     * @param slidingRefreshTokenLifetime 
     * @param refreshTokenUsage 
     * @param updateAccessTokenClaimsOnRefresh 
     * @param refreshTokenExpiration 
     * @param accessTokenType 
     * @param enableLocalLogin 
     * @param identityProviderRestrictions 
     * @param includeJwtId 
     * @param claims 
     * @param alwaysSendClientClaims 
     * @param prefixClientClaims 
     * @param allowedCorsOrigins 
     * @param properties 
     */
    public clientPostWithHttpInfo(id?: number, enabled?: boolean, clientId?: string, normalizedClientId?: string, protocolType?: string, clientSecrets?: Array<string>, requireClientSecret?: boolean, clientName?: string, description?: string, clientUri?: string, logoUri?: string, requireConsent?: boolean, allowRememberConsent?: boolean, alwaysIncludeUserClaimsInIdToken?: boolean, allowedGrantTypes?: Array<string>, requirePkce?: boolean, allowPlainTextPkce?: boolean, allowAccessTokensViaBrowser?: boolean, redirectUris?: Array<string>, postLogoutRedirectUris?: Array<string>, frontChannelLogoutUri?: string, frontChannelLogoutSessionRequired?: boolean, backChannelLogoutUri?: string, backChannelLogoutSessionRequired?: boolean, allowOfflineAccess?: boolean, allowedScopes?: Array<string>, identityTokenLifetime?: number, accessTokenLifetime?: number, authorizationCodeLifetime?: number, consentLifetime?: number, absoluteRefreshTokenLifetime?: number, slidingRefreshTokenLifetime?: number, refreshTokenUsage?: number, updateAccessTokenClaimsOnRefresh?: boolean, refreshTokenExpiration?: number, accessTokenType?: number, enableLocalLogin?: boolean, identityProviderRestrictions?: Array<string>, includeJwtId?: boolean, claims?: Array<string>, alwaysSendClientClaims?: boolean, prefixClientClaims?: boolean, allowedCorsOrigins?: Array<string>, properties?: Array<string>, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/Client`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (id !== undefined) {
            queryParameters.set('Id', <any>id);
        }
        if (enabled !== undefined) {
            queryParameters.set('Enabled', <any>enabled);
        }
        if (clientId !== undefined) {
            queryParameters.set('ClientId', <any>clientId);
        }
        if (normalizedClientId !== undefined) {
            queryParameters.set('NormalizedClientId', <any>normalizedClientId);
        }
        if (protocolType !== undefined) {
            queryParameters.set('ProtocolType', <any>protocolType);
        }
        if (clientSecrets !== undefined) {
            queryParameters.set('ClientSecrets', <any>clientSecrets);
        }
        if (requireClientSecret !== undefined) {
            queryParameters.set('RequireClientSecret', <any>requireClientSecret);
        }
        if (clientName !== undefined) {
            queryParameters.set('ClientName', <any>clientName);
        }
        if (description !== undefined) {
            queryParameters.set('Description', <any>description);
        }
        if (clientUri !== undefined) {
            queryParameters.set('ClientUri', <any>clientUri);
        }
        if (logoUri !== undefined) {
            queryParameters.set('LogoUri', <any>logoUri);
        }
        if (requireConsent !== undefined) {
            queryParameters.set('RequireConsent', <any>requireConsent);
        }
        if (allowRememberConsent !== undefined) {
            queryParameters.set('AllowRememberConsent', <any>allowRememberConsent);
        }
        if (alwaysIncludeUserClaimsInIdToken !== undefined) {
            queryParameters.set('AlwaysIncludeUserClaimsInIdToken', <any>alwaysIncludeUserClaimsInIdToken);
        }
        if (allowedGrantTypes !== undefined) {
            queryParameters.set('AllowedGrantTypes', <any>allowedGrantTypes);
        }
        if (requirePkce !== undefined) {
            queryParameters.set('RequirePkce', <any>requirePkce);
        }
        if (allowPlainTextPkce !== undefined) {
            queryParameters.set('AllowPlainTextPkce', <any>allowPlainTextPkce);
        }
        if (allowAccessTokensViaBrowser !== undefined) {
            queryParameters.set('AllowAccessTokensViaBrowser', <any>allowAccessTokensViaBrowser);
        }
        if (redirectUris !== undefined) {
            queryParameters.set('RedirectUris', <any>redirectUris);
        }
        if (postLogoutRedirectUris !== undefined) {
            queryParameters.set('PostLogoutRedirectUris', <any>postLogoutRedirectUris);
        }
        if (frontChannelLogoutUri !== undefined) {
            queryParameters.set('FrontChannelLogoutUri', <any>frontChannelLogoutUri);
        }
        if (frontChannelLogoutSessionRequired !== undefined) {
            queryParameters.set('FrontChannelLogoutSessionRequired', <any>frontChannelLogoutSessionRequired);
        }
        if (backChannelLogoutUri !== undefined) {
            queryParameters.set('BackChannelLogoutUri', <any>backChannelLogoutUri);
        }
        if (backChannelLogoutSessionRequired !== undefined) {
            queryParameters.set('BackChannelLogoutSessionRequired', <any>backChannelLogoutSessionRequired);
        }
        if (allowOfflineAccess !== undefined) {
            queryParameters.set('AllowOfflineAccess', <any>allowOfflineAccess);
        }
        if (allowedScopes !== undefined) {
            queryParameters.set('AllowedScopes', <any>allowedScopes);
        }
        if (identityTokenLifetime !== undefined) {
            queryParameters.set('IdentityTokenLifetime', <any>identityTokenLifetime);
        }
        if (accessTokenLifetime !== undefined) {
            queryParameters.set('AccessTokenLifetime', <any>accessTokenLifetime);
        }
        if (authorizationCodeLifetime !== undefined) {
            queryParameters.set('AuthorizationCodeLifetime', <any>authorizationCodeLifetime);
        }
        if (consentLifetime !== undefined) {
            queryParameters.set('ConsentLifetime', <any>consentLifetime);
        }
        if (absoluteRefreshTokenLifetime !== undefined) {
            queryParameters.set('AbsoluteRefreshTokenLifetime', <any>absoluteRefreshTokenLifetime);
        }
        if (slidingRefreshTokenLifetime !== undefined) {
            queryParameters.set('SlidingRefreshTokenLifetime', <any>slidingRefreshTokenLifetime);
        }
        if (refreshTokenUsage !== undefined) {
            queryParameters.set('RefreshTokenUsage', <any>refreshTokenUsage);
        }
        if (updateAccessTokenClaimsOnRefresh !== undefined) {
            queryParameters.set('UpdateAccessTokenClaimsOnRefresh', <any>updateAccessTokenClaimsOnRefresh);
        }
        if (refreshTokenExpiration !== undefined) {
            queryParameters.set('RefreshTokenExpiration', <any>refreshTokenExpiration);
        }
        if (accessTokenType !== undefined) {
            queryParameters.set('AccessTokenType', <any>accessTokenType);
        }
        if (enableLocalLogin !== undefined) {
            queryParameters.set('EnableLocalLogin', <any>enableLocalLogin);
        }
        if (identityProviderRestrictions !== undefined) {
            queryParameters.set('IdentityProviderRestrictions', <any>identityProviderRestrictions);
        }
        if (includeJwtId !== undefined) {
            queryParameters.set('IncludeJwtId', <any>includeJwtId);
        }
        if (claims !== undefined) {
            queryParameters.set('Claims', <any>claims);
        }
        if (alwaysSendClientClaims !== undefined) {
            queryParameters.set('AlwaysSendClientClaims', <any>alwaysSendClientClaims);
        }
        if (prefixClientClaims !== undefined) {
            queryParameters.set('PrefixClientClaims', <any>prefixClientClaims);
        }
        if (allowedCorsOrigins !== undefined) {
            queryParameters.set('AllowedCorsOrigins', <any>allowedCorsOrigins);
        }
        if (properties !== undefined) {
            queryParameters.set('Properties', <any>properties);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];
        
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param enabled 
     * @param clientId 
     * @param normalizedClientId 
     * @param protocolType 
     * @param clientSecrets 
     * @param requireClientSecret 
     * @param clientName 
     * @param description 
     * @param clientUri 
     * @param logoUri 
     * @param requireConsent 
     * @param allowRememberConsent 
     * @param alwaysIncludeUserClaimsInIdToken 
     * @param allowedGrantTypes 
     * @param requirePkce 
     * @param allowPlainTextPkce 
     * @param allowAccessTokensViaBrowser 
     * @param redirectUris 
     * @param postLogoutRedirectUris 
     * @param frontChannelLogoutUri 
     * @param frontChannelLogoutSessionRequired 
     * @param backChannelLogoutUri 
     * @param backChannelLogoutSessionRequired 
     * @param allowOfflineAccess 
     * @param allowedScopes 
     * @param identityTokenLifetime 
     * @param accessTokenLifetime 
     * @param authorizationCodeLifetime 
     * @param consentLifetime 
     * @param absoluteRefreshTokenLifetime 
     * @param slidingRefreshTokenLifetime 
     * @param refreshTokenUsage 
     * @param updateAccessTokenClaimsOnRefresh 
     * @param refreshTokenExpiration 
     * @param accessTokenType 
     * @param enableLocalLogin 
     * @param identityProviderRestrictions 
     * @param includeJwtId 
     * @param claims 
     * @param alwaysSendClientClaims 
     * @param prefixClientClaims 
     * @param allowedCorsOrigins 
     * @param properties 
     */
    public clientPutWithHttpInfo(id?: number, enabled?: boolean, clientId?: string, normalizedClientId?: string, protocolType?: string, clientSecrets?: Array<string>, requireClientSecret?: boolean, clientName?: string, description?: string, clientUri?: string, logoUri?: string, requireConsent?: boolean, allowRememberConsent?: boolean, alwaysIncludeUserClaimsInIdToken?: boolean, allowedGrantTypes?: Array<string>, requirePkce?: boolean, allowPlainTextPkce?: boolean, allowAccessTokensViaBrowser?: boolean, redirectUris?: Array<string>, postLogoutRedirectUris?: Array<string>, frontChannelLogoutUri?: string, frontChannelLogoutSessionRequired?: boolean, backChannelLogoutUri?: string, backChannelLogoutSessionRequired?: boolean, allowOfflineAccess?: boolean, allowedScopes?: Array<string>, identityTokenLifetime?: number, accessTokenLifetime?: number, authorizationCodeLifetime?: number, consentLifetime?: number, absoluteRefreshTokenLifetime?: number, slidingRefreshTokenLifetime?: number, refreshTokenUsage?: number, updateAccessTokenClaimsOnRefresh?: boolean, refreshTokenExpiration?: number, accessTokenType?: number, enableLocalLogin?: boolean, identityProviderRestrictions?: Array<string>, includeJwtId?: boolean, claims?: Array<string>, alwaysSendClientClaims?: boolean, prefixClientClaims?: boolean, allowedCorsOrigins?: Array<string>, properties?: Array<string>, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/Client`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (id !== undefined) {
            queryParameters.set('Id', <any>id);
        }
        if (enabled !== undefined) {
            queryParameters.set('Enabled', <any>enabled);
        }
        if (clientId !== undefined) {
            queryParameters.set('ClientId', <any>clientId);
        }
        if (normalizedClientId !== undefined) {
            queryParameters.set('NormalizedClientId', <any>normalizedClientId);
        }
        if (protocolType !== undefined) {
            queryParameters.set('ProtocolType', <any>protocolType);
        }
        if (clientSecrets !== undefined) {
            queryParameters.set('ClientSecrets', <any>clientSecrets);
        }
        if (requireClientSecret !== undefined) {
            queryParameters.set('RequireClientSecret', <any>requireClientSecret);
        }
        if (clientName !== undefined) {
            queryParameters.set('ClientName', <any>clientName);
        }
        if (description !== undefined) {
            queryParameters.set('Description', <any>description);
        }
        if (clientUri !== undefined) {
            queryParameters.set('ClientUri', <any>clientUri);
        }
        if (logoUri !== undefined) {
            queryParameters.set('LogoUri', <any>logoUri);
        }
        if (requireConsent !== undefined) {
            queryParameters.set('RequireConsent', <any>requireConsent);
        }
        if (allowRememberConsent !== undefined) {
            queryParameters.set('AllowRememberConsent', <any>allowRememberConsent);
        }
        if (alwaysIncludeUserClaimsInIdToken !== undefined) {
            queryParameters.set('AlwaysIncludeUserClaimsInIdToken', <any>alwaysIncludeUserClaimsInIdToken);
        }
        if (allowedGrantTypes !== undefined) {
            queryParameters.set('AllowedGrantTypes', <any>allowedGrantTypes);
        }
        if (requirePkce !== undefined) {
            queryParameters.set('RequirePkce', <any>requirePkce);
        }
        if (allowPlainTextPkce !== undefined) {
            queryParameters.set('AllowPlainTextPkce', <any>allowPlainTextPkce);
        }
        if (allowAccessTokensViaBrowser !== undefined) {
            queryParameters.set('AllowAccessTokensViaBrowser', <any>allowAccessTokensViaBrowser);
        }
        if (redirectUris !== undefined) {
            queryParameters.set('RedirectUris', <any>redirectUris);
        }
        if (postLogoutRedirectUris !== undefined) {
            queryParameters.set('PostLogoutRedirectUris', <any>postLogoutRedirectUris);
        }
        if (frontChannelLogoutUri !== undefined) {
            queryParameters.set('FrontChannelLogoutUri', <any>frontChannelLogoutUri);
        }
        if (frontChannelLogoutSessionRequired !== undefined) {
            queryParameters.set('FrontChannelLogoutSessionRequired', <any>frontChannelLogoutSessionRequired);
        }
        if (backChannelLogoutUri !== undefined) {
            queryParameters.set('BackChannelLogoutUri', <any>backChannelLogoutUri);
        }
        if (backChannelLogoutSessionRequired !== undefined) {
            queryParameters.set('BackChannelLogoutSessionRequired', <any>backChannelLogoutSessionRequired);
        }
        if (allowOfflineAccess !== undefined) {
            queryParameters.set('AllowOfflineAccess', <any>allowOfflineAccess);
        }
        if (allowedScopes !== undefined) {
            queryParameters.set('AllowedScopes', <any>allowedScopes);
        }
        if (identityTokenLifetime !== undefined) {
            queryParameters.set('IdentityTokenLifetime', <any>identityTokenLifetime);
        }
        if (accessTokenLifetime !== undefined) {
            queryParameters.set('AccessTokenLifetime', <any>accessTokenLifetime);
        }
        if (authorizationCodeLifetime !== undefined) {
            queryParameters.set('AuthorizationCodeLifetime', <any>authorizationCodeLifetime);
        }
        if (consentLifetime !== undefined) {
            queryParameters.set('ConsentLifetime', <any>consentLifetime);
        }
        if (absoluteRefreshTokenLifetime !== undefined) {
            queryParameters.set('AbsoluteRefreshTokenLifetime', <any>absoluteRefreshTokenLifetime);
        }
        if (slidingRefreshTokenLifetime !== undefined) {
            queryParameters.set('SlidingRefreshTokenLifetime', <any>slidingRefreshTokenLifetime);
        }
        if (refreshTokenUsage !== undefined) {
            queryParameters.set('RefreshTokenUsage', <any>refreshTokenUsage);
        }
        if (updateAccessTokenClaimsOnRefresh !== undefined) {
            queryParameters.set('UpdateAccessTokenClaimsOnRefresh', <any>updateAccessTokenClaimsOnRefresh);
        }
        if (refreshTokenExpiration !== undefined) {
            queryParameters.set('RefreshTokenExpiration', <any>refreshTokenExpiration);
        }
        if (accessTokenType !== undefined) {
            queryParameters.set('AccessTokenType', <any>accessTokenType);
        }
        if (enableLocalLogin !== undefined) {
            queryParameters.set('EnableLocalLogin', <any>enableLocalLogin);
        }
        if (identityProviderRestrictions !== undefined) {
            queryParameters.set('IdentityProviderRestrictions', <any>identityProviderRestrictions);
        }
        if (includeJwtId !== undefined) {
            queryParameters.set('IncludeJwtId', <any>includeJwtId);
        }
        if (claims !== undefined) {
            queryParameters.set('Claims', <any>claims);
        }
        if (alwaysSendClientClaims !== undefined) {
            queryParameters.set('AlwaysSendClientClaims', <any>alwaysSendClientClaims);
        }
        if (prefixClientClaims !== undefined) {
            queryParameters.set('PrefixClientClaims', <any>prefixClientClaims);
        }
        if (allowedCorsOrigins !== undefined) {
            queryParameters.set('AllowedCorsOrigins', <any>allowedCorsOrigins);
        }
        if (properties !== undefined) {
            queryParameters.set('Properties', <any>properties);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain', 
            'application/json', 
            'text/json'
        ];
        
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
